##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
res2
AA
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA
res2 <- onestep(AA, pikR, EPS)
res2
pikR
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
AA
pik[TEST]
res2
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
TEST
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
AA
res2
pikR
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
pik[TEST]
AA
pikR
TEST2
TEST2
pik
pikR
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
pikR
AA
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
AA
res2 <- onestep(AA, pikR, EPS)
res2
pikR
devtools::load_all()
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
?runif
Sys.setenv('_R_CHECK_SYSTEM_CLOCK_' = 0)
install.packages('roxygen2')
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::build_manual()
47/5
10+30+7*3+4*4+5
82/45
82/37
18/45
roxygen2::roxygenise()
devtools::load_all()
Sys.getenv("HOME")
Sys.getenv("R_HOME")
install.packages("rhub")
library(rhub)
check_for_cran()
?build
devtools::load_all(".")
roxygen2::roxygenize()
devtools::load_all(".")
devtools::check_win_devel()
