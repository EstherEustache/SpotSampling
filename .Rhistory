if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
res2
AA
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA
res2 <- onestep(AA, pikR, EPS)
res2
pikR
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
AA
pik[TEST]
res2
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
TEST
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
AA
res2
pikR
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
pik[TEST]
AA
pikR
TEST2
TEST2
pik
pikR
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
EPS <- 1e-8
A   <- X/pik
J   <- ncol(X)
##----------------------------------------------------------------
##                Number of non 0-1 inclusion prob               -
##----------------------------------------------------------------
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else{
B <- A[i,]
}
##---------------------------------------------------------------
##                          Main loop                           -
##---------------------------------------------------------------
while(i_size > 0){
##  if redux is desired
if(redux == TRUE){
pik_tmp <- pik[i]
tmp     <- ReducedMatrix(B)
B_tmp   <- tmp$BB
res     <- onestep(B_tmp, pik_tmp[tmp$ind_row],EPS)
if(is.null(res)){
break
}else{
pik_tmp[tmp$ind_row] <- res
}
pik[i]  <- pik_tmp
}else{
pik[i]  <- onestep(B,pik[i],EPS)
}
##  update i
i      <- which(pik > EPS & pik < (1-EPS))
i_size <- length(i)
##  Depending if we have enough rows
if(i_size >= (J+1)){
i <- i[1:(J+1)]
B <- A[i,]
}else if(i_size > t){
B <- A[i,]
}else{
B <- A[i,]
if(i_size > EPS){
kern <- MASS::Null(B)
if(length(kern) == 0){
break
}
}
}
}
##---------------------------------------------------------------
##                        Landing phase                         -
##---------------------------------------------------------------
TEST <- ((pik>EPS)&(pik<1-EPS))
m    <- 0
pikR <- pik[TEST]
AA   <- ReducedMatrix(A[TEST,])$BB
pikR
AA
AA   <- AA[,1:(ncol(AA)-1)]
res2 <- onestep(AA, pikR, EPS)
res2
if(!is.null(res2)){
pik[TEST] <- res2
TEST      <- ((pik>EPS)&(pik<1-EPS))
print(pik[TEST])
if(any(TEST)){
TEST2     <- ((res2>EPS)&(res2<1-EPS))
pikR      <- pikR[TEST2]
AA        <- AA[TEST2,]
}
}
m    <- m+1
AA   <- AA[,1:(ncol(AA)-1)]
AA
res2 <- onestep(AA, pikR, EPS)
res2
pikR
devtools::load_all()
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
?runif
Sys.setenv('_R_CHECK_SYSTEM_CLOCK_' = 0)
install.packages('roxygen2')
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
devtools::build_manual()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::build_manual()
47/5
10+30+7*3+4*4+5
82/45
82/37
18/45
roxygen2::roxygenise()
devtools::load_all()
Sys.getenv("HOME")
Sys.getenv("R_HOME")
install.packages("rhub")
library(rhub)
check_for_cran()
?build
devtools::load_all(".")
roxygen2::roxygenize()
devtools::load_all(".")
devtools::check_win_devel()
install.packages('WaveSampling')
set.seed(1)
B  <- matrix(sample(c(0,0,0,1),80,replace=TRUE), nrow = 8, ncol =  10)
ReducedMatrix(B)
devtools::load_all()
## Temporal inclusion probabilities with 3 waves and 4 units ##
pik <- matrix(c(0.6,0.3,0.3,
0.2,0.4,0.9,
0.3,0.2,0.5,
0.9,0.1,0.3), ncol = 3, byrow = TRUE)
## ORFS method ##
Orfs(pik)
set.seed(1)
## Matrix of 8 auxilary variables and 10 units with lot of 0s ##
X <- matrix(c(0.6,0.0,0.0,0.0,
0.1,0.0,0.1,0.0,
0.3,0.0,0.0,0.3,
0.0,0.3,0.0,0.3,
0.0,0.6,0.0,0.0,
0.0,0.1,0.1,0.0), ncol = 4, byrow = TRUE)
## Inclusion probabilities with 10 units ##
pik <- c(0.60,0.10,0.30,0.30,0.60,0.10)
## parameter t ##
t <- 2
## Cube method ##
s   <- ReducedSamplecube(X, pik, redux = TRUE, t)
s
B  <- matrix(sample(c(0,0,0,1),80,replace=TRUE), nrow = 8, ncol =  10)
ReducedMatrix(B)
## Coordinates in two dimensions of 4 units ##
coord <- matrix(c(0.5,0.6,0.2,0.3,0.8,0.9,0.4,0.7), ncol=2)
## Temporal inclusion probabilities with 3 waves and 4 units ##
pik <- matrix(c(0.6,0.3,0.3,
0.2,0.4,0.9,
0.3,0.2,0.5,
0.9,0.1,0.3), ncol = 3, byrow = TRUE)
## SPOT method ##
Spot(pik, coord, EPS = 1e-6)
pik1   <- c(0.2,0.3,0.5) # of a first unit
pik2   <- c(0.1,0.4,0.5) # of a second unit
## Find the systematic sampling designs of pik1 and pik2 ##
design1 <- SystematicDesign(pik1, EPS = 1e-6)
design2 <- SystematicDesign(pik2, EPS = 1e-6)
## The time we want to take a decision ##
t    <- 2
d    <- rep(0,3)
d[t] <- 1
## Update probabilities to take a decision at wave t=2 ##
TemporalPivot(design1, design2, d)
devtools::spell_check()
install.packages('commonmark')
library(spelling)
devtools::spell_check()
roxygen2::roxygenise()
devtools::load_all()
devtools::release()
devtools::release()
roxygen2::roxygenise()
devtools::release()
roxygen2::roxygenise()
devtools::spell_check()
roxygen2::roxygenise()
devtools::spell_check()
devtools::load_all(".")
devtools::spell_check()
roxygen2::roxygenize()
devtools::load_all(".")
devtools::load_all(".")
devtools::check_win_devel()
